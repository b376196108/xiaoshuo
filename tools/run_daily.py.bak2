from __future__ import annotations

import argparse
import re
import subprocess
import sys
from pathlib import Path

from chapter_title import format_chapter_heading, generate_chapter_title
from _common import (
    chapter_id,
    get_repo_root,
    infer_next_chapter_num,
    iso_today,
    is_codex_available,
    load_json,
    normalize_chapter_id,
    parse_chapter_id_from_brief,
    parse_chapter_num_from_id,
    parse_target_words_from_brief,
    read_project_scale,
    read_text,
    safe_write_text,
    setup_logger,
)


def _run_py(root: Path, script: Path, args: list[str]) -> int:
    cmd = [sys.executable, str(script)] + args
    p = subprocess.run(cmd, cwd=str(root))
    return int(p.returncode)


def _ensure_repo_dirs(root: Path) -> None:
    for rel in ["manuscript", "recap/chapter_summaries", "state/backups", "logs"]:
        (root / rel).mkdir(parents=True, exist_ok=True)


def _load_project_scale_defaults(root: Path) -> tuple[int | None, int | None]:
    project_brief_path = root / "inputs" / "project_brief.json"
    try:
        project_brief = load_json(project_brief_path)
    except Exception:  # noqa: BLE001
        return None, None
    return read_project_scale(project_brief)


def _resolve_chapter_id(root: Path, run_dir: Path, cli_value: str | None) -> str:
    if cli_value:
        return normalize_chapter_id(cli_value)

    brief_path = run_dir / "brief.md"
    if brief_path.exists():
        chap = parse_chapter_id_from_brief(read_text(brief_path))
        if chap is not None:
            return chap

    return chapter_id(infer_next_chapter_num(root / "manuscript"))


def _resolve_target_words(
    run_dir: Path, *, cli_words: int | None, default_words_per_chapter: int | None
) -> int:
    if cli_words is not None and cli_words > 0:
        return cli_words

    brief_path = run_dir / "brief.md"
    if brief_path.exists():
        words = parse_target_words_from_brief(read_text(brief_path))
        if words is not None:
            return words

    if default_words_per_chapter is not None and default_words_per_chapter > 0:
        return default_words_per_chapter

    return 2500


def _write_manual_instructions(
    run_dir: Path, *, run_date: str, chap: str, target_words: int, total_chapters: int | None
) -> Path:
    out = run_dir / "manual_codex_instructions.md"
    total_line = (
        f"- total_chapters: {total_chapters}" if total_chapters is not None else "- total_chapters: (unknown)"
    )
    text = f"""# 手动 Codex 指令 - {run_date} - {chap}

> 提示：未检测到 `codex` CLI，本次无法自动生成产物。
> 请使用 VSCode Codex 扩展并按顺序执行以下步骤。
> 输出路径必须完全一致（不要改名或移动）。
> 编码强提醒：所有新建/覆盖的 .md/.json 文件必须保存为 UTF-8；若出现大量问号（????），说明编码错误或占位符，必须重做。
> 硬规则：正文（不含标题与空白）必须 >=3000 字符（建议 3200+）；不足返工；禁止灌水凑字。
> 只允许写入指定文件，禁止修改其他任何文件；如需修改其他文件必须先停止并说明原因。
> 遇到缺失文件或读取失败，请先停止并报告，不要擅自补写或猜测。
> 禁止占位符：不得出现 "???" / "TBD" / "待补全" / "TODO"。

## 运行目标

- chapter_id: `{chap}`
- target_words: `{target_words}`
{total_line}

## 需要产出（路径）
- `runs/{run_date}/chapter_plan.md`
- `manuscript/{chap}.md`
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json`（JSON 对象，仅 delta；必须包含 `meta.current_chapter: "{chap}"`）
- `runs/{run_date}/changelog.md`
- `runs/{run_date}/qa_report.md`（由 Step 4 生成）

## 操作总则（必须遵守）

- 全中文输出；严格遵守 `canon/style/style_guide.md`。
- 仅写入指定文件；禁止改动其他文件、路径与文件名。
- 不得生成任何额外正文样稿或新文件；如需修改其他文件请先停止说明原因。
- 不得出现 AI/系统/提示词痕迹；不得使用 "???" / "TBD" / "待补全" / "TODO" 作为占位。

## 步骤 1 - 章纲

提供以下文件作为上下文：
- `AGENTS.md`
- `runs/{run_date}/brief.md`
- `runs/{run_date}/context_pack.md`
- `prompts/roles/plot_architect.md`
- `prompts/roles/chapter_planner.md`

写入：
- `runs/{run_date}/chapter_plan.md`

要求：
- 必须包含 `chapter_title` 字段（最终标题，中文爽文风格，避免“第X章”式空标题）。

## 步骤 2 - 正文 + 行文润色

提供以下文件作为上下文：
- `runs/{run_date}/chapter_plan.md`
- `runs/{run_date}/context_pack.md`
- `canon/style/style_guide.md`
- `prompts/roles/drafter.md`
- `prompts/roles/line_editor.md`

写入：
- `manuscript/{chap}.md`（第一行必须是 `# {chap}`；第二行必须是 `## 《...》`，标题来自 chapter_plan 的 `chapter_title`）

## 步骤 3 - 摘要 + 滚动摘要 + 状态补丁（Archivist）

提供以下文件作为上下文：
- `manuscript/{chap}.md`
- `runs/{run_date}/chapter_plan.md`
- `state/current_state.json`
- `prompts/roles/archivist.md`

写入：
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json`（JSON 对象，仅 delta；`meta.current_chapter` 必须是字符串 "{chap}"）
- `runs/{run_date}/changelog.md`

## 可复制粘贴提示词块（用于 VSCode Codex）
【复制粘贴块 1：Step1 章纲提示词】
```
请只执行【第1步：章纲】。

必须先阅读这些文件作为上下文：
- AGENTS.md
- runs/{run_date}/brief.md
- runs/{run_date}/context_pack.md
- prompts/roles/plot_architect.md
- prompts/roles/chapter_planner.md

然后写出并仅写入：
- runs/{run_date}/chapter_plan.md

要求：
- 全中文输出
- 只写指定文件，禁止修改其他任何文件
- chapter_plan.md 必须包含 chapter_title 字段（最终标题）
- 禁止使用 "???" / "TBD" / "待补全" / "TODO" 占位符
- 若缺失上下文文件，先停止并报告缺失
```

【复制粘贴块 2：Step2 正文+润色提示词】
```
请只执行【第2步：正文+润色】。

必须先阅读这些文件作为上下文：
- runs/{run_date}/chapter_plan.md
- runs/{run_date}/context_pack.md
- canon/style/style_guide.md
- prompts/roles/drafter.md
- prompts/roles/line_editor.md

然后写出并仅写入：
- manuscript/{chap}.md

硬规则：
- 第一行必须是：# {chap}
- 第二行必须是：## 《本章标题》（标题来自 chapter_plan.md 的 chapter_title）
- 正文（不含标题与空白）>=3000 字符，建议 3200–3800
- 禁止灌水凑字：重复句、流水账旁白、无意义心理独白、长篇科普说明书
- 必须包含：行动推进 + 对话交锋 + 场景细节 + 阻碍升级 + 小爽点落地 + 结尾钩子
- 语言必须中文，严格遵守 canon/style/style_guide.md
- 禁止使用 "???" / "TBD" / "待补全" / "TODO" 占位符
- 只写指定文件，禁止修改其他任何文件；若缺失文件先停止并报告
```

【复制粘贴块 3：Step3 归档同步提示词】
```
请只执行【第3步：归档同步】（不要改正文）。

必须先阅读这些文件作为上下文：
- manuscript/{chap}.md
- runs/{run_date}/chapter_plan.md
- state/current_state.json
- prompts/roles/archivist.md

然后写出/更新并仅写入：
- recap/chapter_summaries/{chap}.md
- recap/rolling_recap.md
- state/state_patch.json
- runs/{run_date}/changelog.md

硬规则：
- 全中文输出；只写指定文件，禁止修改其他任何文件
- state/state_patch.json 必须是 JSON 对象、delta only，不得复制整份 current_state
- 必须包含 meta.current_chapter: "{chap}"
- 只能更新本章确实变化的人物状态/资源/地点/关系/knowledge_flags
- open_loops 至少推进 2 条（若无法推进，必须说明原因）
- 归档内容不得引入 manuscript/{chap}.md 未发生的新事实
- changelog 必须追加 synced_at 时间戳
- 禁止使用 "???" / "TBD" / "待补全" / "TODO" 占位符
- 若缺失文件或读取失败，先停止并报告
```

## 步骤 4 - QA + 合并（仅 PASS）
在仓库根目录执行：
```bash
python tools/continuity_checks.py --date {run_date} --chapter {chap}
```

该命令会生成/更新 `runs/{run_date}/qa_report.md`（首行 `QA_RESULT: PASS/FAIL`）。
若 `QA_RESULT: PASS`，再执行：
```bash
python tools/merge_state_patch.py --date {run_date}
```

## 常见失败与处理
- BodyTooShort：只扩写 `manuscript/{chap}.md` 正文（不改其他文件）→重跑 Step3 →再跑 QA。
- OutOfSync：查看 `runs/{run_date}/resync_instructions.md` 并按其指引执行，然后重跑 QA。
- TitleMissingOrInvalid：修正正文标题为 `# {chap}` + `## 《标题》`，标题来自 chapter_plan.md 的 chapter_title →重跑 Step3 →再跑 QA。
"""
    safe_write_text(out, text + "\n", backup=True)
    return out


def _ensure_trailing_newline(text: str) -> str:
    return text if text.endswith("\n") else text + "\n"


_TITLE_LINE_RE = re.compile(r"^##\s+《.+》\s*$")
_LEGACY_TITLE_RE = re.compile(r"^##\s*第\d+章[:：]\s*(.+)$")


def _is_title_line(line: str) -> bool:
    return bool(_TITLE_LINE_RE.match(line.strip()))


def _extract_legacy_title(line: str) -> str | None:
    match = _LEGACY_TITLE_RE.match(line.strip())
    if match:
        return match.group(1).strip()
    return None


def _extract_plan_heading_title(line: str, chap: str) -> str | None:
    if line.startswith(f"# {chap} — "):
        return line.split("—", 1)[1].strip()
    if line.startswith(f"# {chap} - "):
        return line.split("-", 1)[1].strip()
    return None


def _first_line_has_title(line: str, chap: str) -> bool:
    return _extract_plan_heading_title(line, chap) is not None


def _insert_title_in_plan(chap: str, title: str, text: str) -> tuple[str, bool]:
    lines = text.splitlines()
    if lines and _first_line_has_title(lines[0], chap):
        return text, False
    new_text = f"# {chap} — {title}\n{text}" if text else f"# {chap} — {title}\n"
    return _ensure_trailing_newline(new_text), True


def _insert_title_in_manuscript(chap: str, title: str, text: str) -> tuple[str, bool, str]:
    lines = text.splitlines()
    if not lines:
        return text, False, "empty manuscript"
    if lines[0].strip() != f"# {chap}":
        return text, False, "invalid manuscript header"
    if len(lines) > 1:
        if _is_title_line(lines[1]):
            return text, False, ""
        legacy_title = _extract_legacy_title(lines[1])
        if legacy_title:
            heading = format_chapter_heading(chap, legacy_title)
            rest = lines[2:] if len(lines) > 2 else []
            new_lines = [lines[0], heading, ""]
            new_lines.extend(rest)
            return _ensure_trailing_newline("\n".join(new_lines)), True, ""
    heading = format_chapter_heading(chap, title)
    new_lines = [lines[0], heading, ""]
    new_lines.extend(lines[1:])
    return _ensure_trailing_newline("\n".join(new_lines)), True, ""


def _insert_title_in_summary(chap: str, title: str, text: str) -> tuple[str, bool]:
    lines = text.splitlines()
    if lines:
        if _is_title_line(lines[0]):
            return text, False
        legacy_title = _extract_legacy_title(lines[0])
        if legacy_title:
            heading = format_chapter_heading(chap, legacy_title)
            rest = "\n".join(lines[1:])
            new_text = f"{heading}\n\n{rest}" if rest else f"{heading}\n"
            return _ensure_trailing_newline(new_text), True
        plan_heading_title = _extract_plan_heading_title(lines[0], chap)
        if plan_heading_title:
            heading = format_chapter_heading(chap, plan_heading_title)
            rest = "\n".join(lines[1:])
            new_text = f"{heading}\n\n{rest}" if rest else f"{heading}\n"
            return _ensure_trailing_newline(new_text), True
    heading = format_chapter_heading(chap, title)
    new_text = f"{heading}\n\n{text}" if text else f"{heading}\n"
    return _ensure_trailing_newline(new_text), True


def _append_changelog(changelog_path: Path, line: str) -> None:
    if changelog_path.exists():
        existing = read_text(changelog_path)
        if line in existing:
            return
        new_text = existing.rstrip("\n") + "\n" + line + "\n"
    else:
        new_text = line + "\n"
    safe_write_text(changelog_path, new_text, backup=True)


def _auto_title(root: Path, run_dir: Path, chap: str, *, log) -> None:
    plan_path = run_dir / "chapter_plan.md"
    manuscript_path = root / "manuscript" / f"{chap}.md"
    summary_path = root / "recap" / "chapter_summaries" / f"{chap}.md"
    missing = [p for p in (plan_path, manuscript_path) if not p.exists()]
    if missing:
        msg = f"AutoTitle skipped: missing file {missing[0].as_posix()}"
        log.warning(msg)
        print(msg)
        return

    try:
        plan_text = read_text(plan_path)
        chapter_text = read_text(manuscript_path)
    except OSError as exc:
        msg = f"AutoTitle skipped: failed to read file ({exc})"
        log.warning(msg)
        print(msg)
        return

    summary_text = ""
    if summary_path.exists():
        try:
            summary_text = read_text(summary_path)
        except OSError as exc:
            msg = f"AutoTitle skipped: failed to read summary ({exc})"
            log.warning(msg)
            print(msg)

    try:
        project_brief = load_json(root / "inputs" / "project_brief.json")
    except Exception:  # noqa: BLE001
        project_brief = {}

    title = generate_chapter_title(chap, chapter_text, plan_text, summary_text, project_brief)
    if not title:
        title = "荒年第一局"

    changed = False
    plan_text_new, plan_changed = _insert_title_in_plan(chap, title, plan_text)
    if plan_changed:
        safe_write_text(plan_path, plan_text_new, backup=True)
        changed = True

    manuscript_text_new, manuscript_changed, warn = _insert_title_in_manuscript(
        chap, title, chapter_text
    )
    if warn:
        msg = f"AutoTitle skipped: {warn} ({manuscript_path.as_posix()})"
        log.warning(msg)
        print(msg)
    elif manuscript_changed:
        safe_write_text(manuscript_path, manuscript_text_new, backup=True)
        changed = True

    if summary_path.exists():
        summary_text_new, summary_changed = _insert_title_in_summary(chap, title, summary_text)
        if summary_changed:
            safe_write_text(summary_path, summary_text_new, backup=True)
            changed = True

    if changed:
        _append_changelog(run_dir / "changelog.md", f"- AutoTitle: {chap} -> {title}")


def _codex_prompt(run_date: str, chap: str, *, target_words: int, total_chapters: int | None) -> str:
    scale_line = (
        f"- Project scale: total_chapters={total_chapters}"
        if total_chapters is not None
        else "- Project scale: total_chapters=(unknown)"
    )
    return f"""You are the Novel Studio AI writing team operating inside the `xiaoshuo/` repo.

Hard rules:
- Follow `AGENTS.md` strictly (no AI/system traces in the manuscript).
- Do NOT directly edit `state/current_state.json`. Only write `state/state_patch.json`.
- Keep POV/tense/style locked by `canon/style/style_guide.md` and `state/current_state.json`.
- Advance at least 2 open_loops; add at most 1 new open_loop; ending must have a hook.
- chapter_plan.md MUST include a `chapter_title` field (final title).
- manuscript line 1 must be `# {chap}` and line 2 must be `## 《...》` using chapter_title.
- Output must be Chinese and must not include placeholders (???/TBD/TODO).

Run targets:
- chapter_id: {chap}
- target_words: ~{target_words}
{scale_line}

Read:
- `runs/{run_date}/brief.md`
- `runs/{run_date}/context_pack.md`
- Role prompts under `prompts/roles/`

Produce the following files (exact paths):
- `runs/{run_date}/chapter_plan.md`
- `manuscript/{chap}.md` (line 1 `# {chap}`, line 2 `## 《...》`)
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json` (JSON object, delta only; MUST include `meta.current_chapter` = "{chap}" as a STRING)
- `runs/{run_date}/changelog.md`

Do not generate any extra story samples beyond the required chapter file.
"""


def main() -> int:
    parser = argparse.ArgumentParser(description="Production daily entrypoint.")
    parser.add_argument("--date", default=iso_today(), help="Run date (YYYY-MM-DD). Default: today.")
    parser.add_argument("--chapter", type=str, default=None, help="Chapter id (chNNN) or number (NNN).")
    parser.add_argument(
        "--words",
        type=int,
        default=None,
        help="Target words (priority: CLI > brief.md > project_brief.json > 2500).",
    )
    parser.add_argument("--max-chars", type=int, default=80000, help="Max chars for context_pack.md.")
    parser.add_argument("--force-manual", action="store_true", help="Always generate manual instructions and skip codex.")
    args = parser.parse_args()

    root = get_repo_root()
    _ensure_repo_dirs(root)

    run_dir = root / "runs" / args.date
    run_dir.mkdir(parents=True, exist_ok=True)
    log = setup_logger("run_daily", log_file=run_dir / "run_daily.log", verbose=False)

    total_chapters, default_words_per_chapter = _load_project_scale_defaults(root)
    chap = _resolve_chapter_id(root, run_dir, args.chapter)
    chapter_num = parse_chapter_num_from_id(chap)
    if chapter_num is None:
        log.error("Invalid chapter id resolved: %s", chap)
        return 2

    target_words = _resolve_target_words(
        run_dir, cli_words=args.words, default_words_per_chapter=default_words_per_chapter
    )
    if target_words < 3000:
        log.warning("target_words=%s below minimum; using 3200", target_words)
        target_words = 3200
    log.info("date=%s chapter=%s target_words=%s", args.date, chap, target_words)

    # 1) CreateRun
    rc = _run_py(
        root,
        root / "tools" / "create_daily_run.py",
        ["--date", args.date, "--chapter", chap] + (["--words", str(args.words)] if args.words else []),
    )
    if rc != 0:
        log.error("create_daily_run failed: rc=%s", rc)
        return rc

    # 2) BuildContext
    rc = _run_py(root, root / "tools" / "build_context_pack.py", ["--date", args.date, "--max-chars", str(args.max_chars)])
    if rc != 0:
        log.error("build_context_pack failed: rc=%s", rc)
        return rc

    # 3) Generate with codex CLI or manual instructions.
    manual_mode = args.force_manual or not is_codex_available()
    if manual_mode:
        manual = _write_manual_instructions(
            run_dir,
            run_date=args.date,
            chap=chap,
            target_words=target_words,
            total_chapters=total_chapters,
        )
        log.warning("codex not available; manual instructions written: %s", manual.as_posix())
        print(f"[INFO] codex CLI not available; wrote manual instructions: {manual.as_posix()}")
        _auto_title(root, run_dir, chap, log=log)
        _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
        return 2

    stdout_log = run_dir / "codex_stdout.log"
    stderr_log = run_dir / "codex_stderr.log"
    prompt = _codex_prompt(args.date, chap, target_words=target_words, total_chapters=total_chapters)
    with stdout_log.open("w", encoding="utf-8", newline="\n") as out, stderr_log.open(
        "w", encoding="utf-8", newline="\n"
    ) as err:
        p = subprocess.run(
            ["codex", "exec", "--full-auto"],
            input=prompt,
            text=True,
            cwd=str(root),
            stdout=out,
            stderr=err,
        )
    if p.returncode != 0:
        manual = _write_manual_instructions(
            run_dir,
            run_date=args.date,
            chap=chap,
            target_words=target_words,
            total_chapters=total_chapters,
        )
        log.error("codex exec failed: rc=%s", p.returncode)
        print(f"[ERROR] codex exec failed (rc={p.returncode}). See logs in {run_dir.as_posix()}.")
        print(f"[INFO] Fallback manual instructions: {manual.as_posix()}")
        _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
        return int(p.returncode)

    # 4) AutoTitle (after artifacts, before QA)
    _auto_title(root, run_dir, chap, log=log)

    # 4) continuity_checks
    rc = _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
    if rc != 0:
        log.error("QA failed: rc=%s", rc)
        print(f"[ERROR] QA failed. See: {(run_dir / 'qa_report.md').as_posix()}")
        return rc

    # 5) Patch + Merge (only PASS)
    patch_path = root / "state" / "state_patch.json"
    if not patch_path.exists():
        _run_py(root, root / "tools" / "extract_state_patch.py", ["--date", args.date, "--chapter", chap])

    rc = _run_py(root, root / "tools" / "merge_state_patch.py", ["--date", args.date])
    if rc != 0:
        log.error("merge_state_patch failed: rc=%s", rc)
    else:
        log.info("daily run completed: PASS + merged state patch")
    return rc


if __name__ == "__main__":
    raise SystemExit(main())
