from __future__ import annotations

import argparse
import subprocess
import sys
from pathlib import Path

from _common import (
    chapter_id,
    get_repo_root,
    infer_next_chapter_num,
    iso_today,
    is_codex_available,
    load_json,
    normalize_chapter_id,
    parse_chapter_id_from_brief,
    parse_chapter_num_from_id,
    parse_target_words_from_brief,
    read_project_scale,
    read_text,
    safe_write_text,
    setup_logger,
)


def _run_py(root: Path, script: Path, args: list[str]) -> int:
    cmd = [sys.executable, str(script)] + args
    p = subprocess.run(cmd, cwd=str(root))
    return int(p.returncode)


def _ensure_repo_dirs(root: Path) -> None:
    for rel in ["manuscript", "recap/chapter_summaries", "state/backups", "logs"]:
        (root / rel).mkdir(parents=True, exist_ok=True)


def _load_project_scale_defaults(root: Path) -> tuple[int | None, int | None]:
    project_brief_path = root / "inputs" / "project_brief.json"
    try:
        project_brief = load_json(project_brief_path)
    except Exception:  # noqa: BLE001
        return None, None
    return read_project_scale(project_brief)


def _resolve_chapter_id(root: Path, run_dir: Path, cli_value: str | None) -> str:
    if cli_value:
        return normalize_chapter_id(cli_value)

    brief_path = run_dir / "brief.md"
    if brief_path.exists():
        chap = parse_chapter_id_from_brief(read_text(brief_path))
        if chap is not None:
            return chap

    return chapter_id(infer_next_chapter_num(root / "manuscript"))


def _resolve_target_words(
    run_dir: Path, *, cli_words: int | None, default_words_per_chapter: int | None
) -> int:
    if cli_words is not None and cli_words > 0:
        return cli_words

    brief_path = run_dir / "brief.md"
    if brief_path.exists():
        words = parse_target_words_from_brief(read_text(brief_path))
        if words is not None:
            return words

    if default_words_per_chapter is not None and default_words_per_chapter > 0:
        return default_words_per_chapter

    return 2500


def _write_manual_instructions(
    run_dir: Path, *, run_date: str, chap: str, target_words: int, total_chapters: int | None
) -> Path:
    out = run_dir / "manual_codex_instructions.md"
    total_line = (
        f"- total_chapters: {total_chapters}" if total_chapters is not None else "- total_chapters: (unknown)"
    )
    text = f"""# Manual Codex Instructions - {run_date} - {chap}

> ??????? `codex` CLI??????????
> ?? VSCode ? Codex ?????????????
> ???????????????????/?????

## Run Targets

- chapter_id: `{chap}`
- target_words: `{target_words}`
{total_line}

## Required Outputs (paths)

- `runs/{run_date}/chapter_plan.md`
- `manuscript/{chap}.md`
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json` (JSON object, delta only; MUST include `meta.current_chapter: "{chap}"`)
- `runs/{run_date}/changelog.md`
- `runs/{run_date}/qa_report.md` (generated by Step 4)

## Step 1 - ?????? (Chapter Plan)

?????????????
- `AGENTS.md`
- `runs/{run_date}/brief.md`
- `runs/{run_date}/context_pack.md`
- `prompts/roles/plot_architect.md`
- `prompts/roles/chapter_planner.md`

????????
- `runs/{run_date}/chapter_plan.md`

## Step 2 - ?? + ????

?????????????
- `runs/{run_date}/chapter_plan.md`
- `runs/{run_date}/context_pack.md`
- `canon/style/style_guide.md`
- `prompts/roles/drafter.md`
- `prompts/roles/line_editor.md`

????????
- `manuscript/{chap}.md`??????? `# {chap}`?

## Step 3 - ?? + ???? + ???? (Archivist)

?????????????
- `manuscript/{chap}.md`
- `runs/{run_date}/chapter_plan.md`
- `state/current_state.json`
- `prompts/roles/archivist.md`

????????
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json`?JSON ?????????`meta.current_chapter` ?????? `"{chap}"`?
- `runs/{run_date}/changelog.md`

## Step 4 - ??????? QA ????? PASS?

?????????

```bash
python tools/continuity_checks.py --date {run_date} --chapter {chap}
```

??????/???`runs/{run_date}/qa_report.md`??? `QA_RESULT: PASS/FAIL`??

?? `QA_RESULT: PASS`?????

```bash
python tools/merge_state_patch.py --date {run_date}
```
"""
    safe_write_text(out, text + "
", backup=True)
    return out


def _codex_prompt(run_date: str, chap: str, *, target_words: int, total_chapters: int | None) -> str:
    scale_line = (
        f"- Project scale: total_chapters={total_chapters}"
        if total_chapters is not None
        else "- Project scale: total_chapters=(unknown)"
    )
    return f"""You are the Novel Studio AI writing team operating inside the `xiaoshuo/` repo.

Hard rules:
- Follow `AGENTS.md` strictly (no AI/system traces in the manuscript).
- Do NOT directly edit `state/current_state.json`. Only write `state/state_patch.json`.
- Keep POV/tense/style locked by `canon/style/style_guide.md` and `state/current_state.json`.
- Advance at least 2 open_loops; add at most 1 new open_loop; ending must have a hook.

Run targets:
- chapter_id: {chap}
- target_words: ~{target_words}
{scale_line}

Read:
- `runs/{run_date}/brief.md`
- `runs/{run_date}/context_pack.md`
- Role prompts under `prompts/roles/`

Produce the following files (exact paths):
- `runs/{run_date}/chapter_plan.md`
- `manuscript/{chap}.md` (start with `# {chap}`)
- `recap/chapter_summaries/{chap}.md`
- `recap/rolling_recap.md`
- `state/state_patch.json` (JSON object, delta only; MUST include `meta.current_chapter` = "{chap}" as a STRING)
- `runs/{run_date}/changelog.md`

Do not generate any extra story samples beyond the required chapter file.
"""


def main() -> int:
    parser = argparse.ArgumentParser(description="Production daily entrypoint.")
    parser.add_argument("--date", default=iso_today(), help="Run date (YYYY-MM-DD). Default: today.")
    parser.add_argument("--chapter", type=str, default=None, help="Chapter id (chNNN) or number (NNN).")
    parser.add_argument(
        "--words",
        type=int,
        default=None,
        help="Target words (priority: CLI > brief.md > project_brief.json > 2500).",
    )
    parser.add_argument("--max-chars", type=int, default=80000, help="Max chars for context_pack.md.")
    parser.add_argument("--force-manual", action="store_true", help="Always generate manual instructions and skip codex.")
    args = parser.parse_args()

    root = get_repo_root()
    _ensure_repo_dirs(root)

    run_dir = root / "runs" / args.date
    run_dir.mkdir(parents=True, exist_ok=True)
    log = setup_logger("run_daily", log_file=run_dir / "run_daily.log", verbose=False)

    total_chapters, default_words_per_chapter = _load_project_scale_defaults(root)
    chap = _resolve_chapter_id(root, run_dir, args.chapter)
    chapter_num = parse_chapter_num_from_id(chap)
    if chapter_num is None:
        log.error("Invalid chapter id resolved: %s", chap)
        return 2

    target_words = _resolve_target_words(
        run_dir, cli_words=args.words, default_words_per_chapter=default_words_per_chapter
    )
    log.info("date=%s chapter=%s target_words=%s", args.date, chap, target_words)

    # 1) CreateRun
    rc = _run_py(
        root,
        root / "tools" / "create_daily_run.py",
        ["--date", args.date, "--chapter", chap] + (["--words", str(args.words)] if args.words else []),
    )
    if rc != 0:
        log.error("create_daily_run failed: rc=%s", rc)
        return rc

    # 2) BuildContext
    rc = _run_py(root, root / "tools" / "build_context_pack.py", ["--date", args.date, "--max-chars", str(args.max_chars)])
    if rc != 0:
        log.error("build_context_pack failed: rc=%s", rc)
        return rc

    # 3) Generate with codex CLI or manual instructions.
    manual_mode = args.force_manual or not is_codex_available()
    if manual_mode:
        manual = _write_manual_instructions(
            run_dir,
            run_date=args.date,
            chap=chap,
            target_words=target_words,
            total_chapters=total_chapters,
        )
        log.warning("codex not available; manual instructions written: %s", manual.as_posix())
        print(f"[INFO] codex CLI not available; wrote manual instructions: {manual.as_posix()}")
        _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
        return 2

    stdout_log = run_dir / "codex_stdout.log"
    stderr_log = run_dir / "codex_stderr.log"
    prompt = _codex_prompt(args.date, chap, target_words=target_words, total_chapters=total_chapters)
    with stdout_log.open("w", encoding="utf-8") as out, stderr_log.open("w", encoding="utf-8") as err:
        p = subprocess.run(
            ["codex", "exec", "--full-auto"],
            input=prompt,
            text=True,
            cwd=str(root),
            stdout=out,
            stderr=err,
        )
    if p.returncode != 0:
        manual = _write_manual_instructions(
            run_dir,
            run_date=args.date,
            chap=chap,
            target_words=target_words,
            total_chapters=total_chapters,
        )
        log.error("codex exec failed: rc=%s", p.returncode)
        print(f"[ERROR] codex exec failed (rc={p.returncode}). See logs in {run_dir.as_posix()}.")
        print(f"[INFO] Fallback manual instructions: {manual.as_posix()}")
        _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
        return int(p.returncode)

    # 4) continuity_checks
    rc = _run_py(root, root / "tools" / "continuity_checks.py", ["--date", args.date, "--chapter", chap])
    if rc != 0:
        log.error("QA failed: rc=%s", rc)
        print(f"[ERROR] QA failed. See: {(run_dir / 'qa_report.md').as_posix()}")
        return rc

    # 5) Patch + Merge (only PASS)
    patch_path = root / "state" / "state_patch.json"
    if not patch_path.exists():
        _run_py(root, root / "tools" / "extract_state_patch.py", ["--date", args.date, "--chapter", chap])

    rc = _run_py(root, root / "tools" / "merge_state_patch.py", ["--date", args.date])
    if rc != 0:
        log.error("merge_state_patch failed: rc=%s", rc)
    else:
        log.info("daily run completed: PASS + merged state patch")
    return rc


if __name__ == "__main__":
    raise SystemExit(main())
